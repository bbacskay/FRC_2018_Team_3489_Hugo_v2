// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3489.FEMAv2.subsystems;

import org.usfirst.frc3489.FEMAv2.RobotMap;
import org.usfirst.frc3489.FEMAv2.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.Solenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Lifter extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double SWITCH_POS = 9000;
    public static final double SCALE_L_POS = 21200;
    public static final double SCALE_H_POS = 27208;
    public static final double LIFTER_TOLERANCE = 10;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX lifter1 = RobotMap.lifterlifter1;
    private final WPI_TalonSRX lifter2 = RobotMap.lifterlifter2;
    private final Solenoid lifterBreak = RobotMap.lifterlifterBreak;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

 // PID for Lifter
 	int PIDloop = 0; // primary PID loop
 	int PIDtimeout = 10;// set to zero to skip waiting for confirmation, set to nonzero to wait and
 	int count = 100;
 	// report to DS if action fails.
 	boolean PIDsensorphase = true; // Talon does not report sensor out of phase
 	boolean PIDpositivevalue = true; // Direction of positive values
 	boolean switchPosition = false;
 	// PID Numbers to play with
 	public double theF = 0.0;
 	public double theP = 0.55;
 	public double theI = 0.0;
 	public double theD = 0.0;
    
    
    public Lifter() {
    	//Invert Motors
    		lifter1.setInverted(true);
    		lifter2.setInverted(true);
    		
    	//PID Setup pt2
			//These values are set in the top of the class, here we use them to configure the talon
			// sensor and sensor direction - multiple ways to configure the talon
			lifter1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, PIDloop,PIDtimeout);
			// ensure sensor is positive when output is positive
			lifter1.setSensorPhase(PIDsensorphase);
			lifter2.setSensorPhase(PIDsensorphase);
			// set direction you want forward/positive to be.
			//Completed 4/7/17 Jake John
			//lifter1.setInverted(PIDpositivevalue);
			//m7.setInverted(PIDpositivevalue);
			// set the peak and nominal outputs, 0 = no power 1 / -1 = full 12volts
			lifter1.configNominalOutputForward(0.2, PIDtimeout); //0.2
			lifter1.configNominalOutputReverse(-0.05, PIDtimeout);
			lifter1.configPeakOutputForward(0.6, PIDtimeout);
			lifter1.configPeakOutputReverse(-0.45, PIDtimeout);
			// allowable closed-loop error, Closed-Loop output will be neutral within this range
			lifter1.configAllowableClosedloopError(0, PIDloop, PIDtimeout);
			// closed loop gains
			lifter1.config_kF(PIDloop, theF, PIDtimeout);
			lifter1.config_kP(PIDloop, theP, PIDtimeout); 
			lifter1.config_kI(PIDloop, theI, PIDtimeout); 
			lifter1.config_kD(PIDloop, theD, PIDtimeout);
			
			//MagEncoder's absolute 360 degree position
			 //set the relative sensor to absolute position
			int absolutePosition = lifter1.getSensorCollection().getPulseWidthPosition();
			/* Here is some stuff from Cross The Roads Electronics that FRC temas need to do
			 * mask out overflows, keep bottom 12 bits */
			absolutePosition &= 0xFFF;
			if (PIDsensorphase)
				absolutePosition *= -1;
			if (PIDpositivevalue)
				absolutePosition *= -1;
			//set the quadrature (relative) sensor to match absolute */
			lifter1.setSelectedSensorPosition(absolutePosition, PIDloop, PIDtimeout);
			
			//Reset Lifter Pos to 0
			lifter1.setSelectedSensorPosition(0, PIDloop, PIDtimeout);
    			
			//lifter2 follows lifter1
			lifter2.follow(lifter1);    
			
			SmartDashboard.putNumber("Lifter PID P", theP);
	    	SmartDashboard.putNumber("Lifter PID I", theI);
	    	SmartDashboard.putNumber("Lifter PID D", theD);
    			
    }
    
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new cmdLifterDefault());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
    	SmartDashboard.putNumber("LiftPosition", getLifterPos());
    	
    	theP = SmartDashboard.getNumber("Lifter PID P", theP);
    	theI = SmartDashboard.getNumber("Lifter PID I", theI);
    	theD = SmartDashboard.getNumber("Lifter PID D", theD);
    }
    /**
     * Moves Lifter to a set height.
     * @param position
     */
    public void gotoPosition(double position) {
    	lifter1.config_kF(PIDloop, theF, PIDtimeout);
		lifter1.config_kP(PIDloop, theP, PIDtimeout); 
		lifter1.config_kI(PIDloop, theI, PIDtimeout); 
		lifter1.config_kD(PIDloop, theD, PIDtimeout);
		
    	lifterBreak.set(false);
    	lifter1.set(ControlMode.Position, position);
    }
    
    public void stopLifter() {
    	lifterBreak.set(true);
    	lifter1.set(ControlMode.PercentOutput, 0);
    }
    
    public double getLifterPos() {
    	return lifter1.getSelectedSensorPosition(0);
    }

    public void lifterUp() {
    	lifterBreak.set(false);
    	lifter1.set(ControlMode.PercentOutput, 1);
    }
    
    public void lifterDown() {
    	lifterBreak.set(false);
    	lifter1.set(ControlMode.PercentOutput, -0.35);
    }
    
    
    public boolean getLifterNegativeEndSwitch() {
    	return lifter1.getSensorCollection().isRevLimitSwitchClosed();
    }
    
    public void lifterResetPosition() {
    	//Reset Lifter Pos to 0
		lifter1.setSelectedSensorPosition(0, PIDloop, PIDtimeout);
    	
    }
}

