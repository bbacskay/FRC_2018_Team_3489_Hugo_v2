// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3489.FEMAv2.subsystems;

import org.usfirst.frc3489.FEMAv2.RobotMap;
import org.usfirst.frc3489.FEMAv2.commands.*;

import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.kauailabs.navx.frc.AHRS;

/**
 *
 */
public class DriveSystem extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double SWITCH_POS = 9000;
    public static final double SCALE_L_POS = 21200;
    public static final double SCALE_H_POS = 27208;
    public static final double LIFTER_TOLERANCE = 10;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX motorFrontLeft = RobotMap.driveSystemMotorFrontLeft;
    private final WPI_TalonSRX motorFrontRight = RobotMap.driveSystemMotorFrontRight;
    private final DifferentialDrive differentialDrive = RobotMap.driveSystemDifferentialDrive;
    private final WPI_TalonSRX motorBackLeft = RobotMap.driveSystemMotorBackLeft;
    private final WPI_TalonSRX motorBackRight = RobotMap.driveSystemMotorBackRight;
    private final DoubleSolenoid boxShifter = RobotMap.driveSystemBoxShifter;
    private final Encoder leftEnc = RobotMap.driveSystemLeftEnc;
    private final Encoder rightEnc = RobotMap.driveSystemRightEnc;
    private final DigitalInput maximumClimb = RobotMap.driveSystemMaximumClimb;
    private final Solenoid climberPin = RobotMap.driveSystemclimberPin;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final AHRS navx = RobotMap.navx;
    public DriveSystem () {
    	driveMode();
    	//Invert all motors because of wiring
    	motorFrontLeft.setInverted(true);
    	motorFrontRight.setInverted(true);
    	motorBackLeft.setInverted(true);
    	motorBackRight.setInverted(true);
    	
    	//Rear motors follow front motors
    	motorBackLeft.follow(motorFrontLeft);
    	motorBackRight.follow(motorFrontRight);
    	

    }

    @Override
    public void initDefaultCommand() {
    	
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TankDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    /**
     * Manual operation of the Drive Train
     * @param Left
     * Input from Left Joystick
     * @param Right
     * Input from Right Joystick
     */
    public void tankDrive(Joystick Left,Joystick Right) {
    	double lValue;
    	double rValue;
    	double inputRatio = -0.85;
    	
    	lValue = Left.getY() * inputRatio;
    	rValue = Right.getY() * inputRatio;
    	
    	differentialDrive.tankDrive(lValue, rValue);
    }
    /**
     *  Switches the Gear Box to apply power to the Drive Train
     */
    public void driveMode() {
    	boxShifter.set(Value.kReverse);
    }
    /**
     *  Switches the Gear Box to apply power to the Climber
     */
    public void climbMode() {
    	boxShifter.set(Value.kForward);
    }
    /**
     * Stops all cim motors on the drive train.
     */
    public void stop() {
    	differentialDrive.tankDrive(0,0);
    }
    
    public void releaseClimber(boolean enable) {
    	if (enable == true) {
    		climberPin.set(true);
    	}
    }
    
    public void resetClimber() {
    	climberPin.set(false);
    }
    
    public void move(double leftSpeed, double rightSpeed) {
    	differentialDrive.tankDrive(leftSpeed, rightSpeed);
    }
    
    public double getRightEncoder() {
    	return rightEnc.getDistance();
    }
    
    public double getLeftEncoder() {
    	return leftEnc.getDistance()* -1;
    }
    
    public void resetEncoders() {
    	rightEnc.reset();
    	leftEnc.reset();
    }
    
    public double getHeading() {
    	return navx.getFusedHeading();
    }
    
    public void resetHeading() {
    	navx.reset();
    }

}
