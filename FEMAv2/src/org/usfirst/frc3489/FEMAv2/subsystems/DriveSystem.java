// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3489.FEMAv2.subsystems;

import org.usfirst.frc3489.FEMAv2.RobotMap;
import org.usfirst.frc3489.FEMAv2.commands.*;

import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Subsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;

/**
 *
 */
public class DriveSystem extends Subsystem implements PIDOutput {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    public static final double SWITCH_POS = 9000;
    public static final double SCALE_L_POS = 21200;
    public static final double SCALE_H_POS = 27208;
    public static final double LIFTER_TOLERANCE = 10;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    /* The following PID Controller coefficients will need to be tuned */
    /* to match the dynamics of your drive system.  Note that the      */
    /* SmartDashboard in Test mode has support for helping you tune    */
    /* controllers by displaying a form where you can enter new P, I,  */
    /* and D constants and test the mechanism.                         */
    
    static final double kP = 0.02;
    static final double kI = 0.00;
    static final double kD = 0.00;
    static final double kF = 0.00;
    
    static final double kToleranceDegrees = 1.0f;
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX motorFrontLeft = RobotMap.driveSystemMotorFrontLeft;
    private final WPI_TalonSRX motorFrontRight = RobotMap.driveSystemMotorFrontRight;
    private final DifferentialDrive differentialDrive = RobotMap.driveSystemDifferentialDrive;
    private final WPI_TalonSRX motorBackLeft = RobotMap.driveSystemMotorBackLeft;
    private final WPI_TalonSRX motorBackRight = RobotMap.driveSystemMotorBackRight;
    private final DoubleSolenoid boxShifter = RobotMap.driveSystemBoxShifter;
    private final Encoder leftEnc = RobotMap.driveSystemLeftEnc;
    private final Encoder rightEnc = RobotMap.driveSystemRightEnc;
    private final DigitalInput maximumClimb = RobotMap.driveSystemMaximumClimb;
    private final Solenoid climberPin = RobotMap.driveSystemclimberPin;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final AHRS navx = RobotMap.navx;
    
    PIDController turnController;
    double rotateToAngleRate;   
    double targetAngle;
    
    private boolean m_turnMode        = false;
    private boolean m_headingLockMode = false;
    
    private double m_straightSpeed = 0; 
    
    private int testCounter = 0;
    
    /**
     * Constructor of the DriveSystem subsystem
     */
    public DriveSystem () {
    	
    	//Invert all motors because of wiring
    	motorFrontLeft.setInverted(true);
    	motorFrontRight.setInverted(true);
    	motorBackLeft.setInverted(true);
    	motorBackRight.setInverted(true);
    	
    	//Rear motors follow front motors
    	motorBackLeft.follow(motorFrontLeft);
    	motorBackRight.follow(motorFrontRight);
    	
    	// Switch the gearbox into drive mode
    	driveMode();
    	
    	//Init PID controller
    	turnController = new PIDController(kP, kI, kD, kF, navx, this);
        turnController.setInputRange(-180.0f,  180.0f);
        turnController.setOutputRange(-1.0, 1.0);
        turnController.setAbsoluteTolerance(kToleranceDegrees);
        turnController.setContinuous(true);
        turnController.disable();
        targetAngle = 0;
        
        /* Add the PID Controller to the Test-mode dashboard, allowing manual  */
        /* tuning of the Turn Controller's P, I and D coefficients.            */
        /* Typically, only the P value needs to be modified.                   */
        LiveWindow.add(turnController); 
        
        LiveWindow.add(navx);
    }

    @Override
    public void initDefaultCommand() {
    	
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new TankDrive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    @Override
    public void periodic() {
        // Put code here to be run every loop
    	double leftSpeedValue = 0;
    	double rightSpeedValue = 0;
    	
    	if (m_turnMode) {
    		leftSpeedValue = rotateToAngleRate;
    		rightSpeedValue = -rotateToAngleRate;
    		
    		differentialDrive.tankDrive(leftSpeedValue, rightSpeedValue);
    		
    		System.out.println("Heading: " + getHeading() + "  targetHeading: " + targetAngle + " " + leftSpeedValue + " " + rightSpeedValue);
    	} else if (m_headingLockMode) {
    		leftSpeedValue = m_straightSpeed + rotateToAngleRate;
    		rightSpeedValue = m_straightSpeed - rotateToAngleRate;
    		
    		differentialDrive.tankDrive(leftSpeedValue, rightSpeedValue);
    		
    		System.out.println("Heading: " + getHeading() + "  targetHeading: " + targetAngle + " " + leftSpeedValue + " " + rightSpeedValue);
    	} else {
    		turnController.disable();
    		testCounter = 0;
    	}
    		
    	
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    /**
     * Manual operation of the Drive Train
     * @param Left
     * Input from Left Joystick
     * @param Right
     * Input from Right Joystick
     */
    public void tankDrive(Joystick Left,Joystick Right) {
    	double lValue;
    	double rValue;
    	double inputRatio = -0.85;
    	
    	lValue = Left.getY() * inputRatio;
    	rValue = Right.getY() * inputRatio;
    	
    	differentialDrive.tankDrive(lValue, rValue);
    }
    
    /**
     * Start turning to a given angle
     * 
     * @param angle Target angle. Valid range: -180..180
     */
    public void turnToAngle(double angle) {
    	this.targetAngle  = angle;
    	m_turnMode        = true;
    	m_headingLockMode = false;
    	
    	if (!this.turnController.isEnabled() ) {
    		this.testCounter = 0;
    		this.turnController.setSetpoint(this.targetAngle);
    		this.turnController.enable();
    	}
    }
    
    /**
     * Activate straight driving
     * @param speed Target speed. Range: -1..1
     */
    public void driveStraight(double speed) {
    	m_straightSpeed   = speed;
    	m_turnMode        = false;
    	m_headingLockMode = true;
    	
    	if (!this.turnController.isEnabled() ) {
    		this.targetAngle = navx.getYaw();
    		this.turnController.setSetpoint(this.targetAngle);
    		this.turnController.enable();
    	}
    }
    
    /**
     * Move the robot in tank drive mode with directly setting the left and right speeds
     * @param leftSpeed Left side's speed
     * @param rightSpeed Right side's speed
     */
    public void move(double leftSpeed, double rightSpeed) {
    	m_turnMode        = false;
    	m_headingLockMode = false;
    	
    	differentialDrive.tankDrive(leftSpeed, rightSpeed);
    }
    
    /**
     * Stops all cim motors on the drive train.
     * Turns off the head locking and drive state modes.
     */
    public void stop() {
    	differentialDrive.tankDrive(0,0);
    	
    	m_turnMode        = false;
    	m_headingLockMode = false;
    }
    
    /**
     *  Switches the Gear Box to apply power to the Drive Train
     */
    public void driveMode() {
    	boxShifter.set(Value.kReverse);
    }
    
    /**
     *  Switches the Gear Box to apply power to the Climber
     */
    public void climbMode() {
    	boxShifter.set(Value.kForward);
    	
    	m_turnMode        = false;
    	m_headingLockMode = false;
    }
    
    
    public void releaseClimber(boolean enable) {
    	if (enable == true) {
    		climberPin.set(true);
    	}
    }
    
    public void resetClimber() {
    	climberPin.set(false);
    }
    
    
    public double getRightEncoder() {
    	return rightEnc.getDistance();
    }
    
    public double getLeftEncoder() {
    	return leftEnc.getDistance()* -1;
    }
    
    public void resetEncoders() {
    	rightEnc.reset();
    	leftEnc.reset();
    }
    
    public double getHeading() {
    	return navx.getFusedHeading();
    }
    
    public void resetHeading() {
    	navx.reset();
    }

    
    public boolean getPidOk() {
    	if (turnController.onTarget()) {
    		testCounter++;
    	} else {
    		testCounter = 0;
    	}
    	
    	return testCounter > 10;
    }
    
    @Override
    /* This function is invoked periodically by the PID Controller, */
    /* based upon navX MXP yaw angle input and PID Coefficients.    */
    public void pidWrite(double output) {
        rotateToAngleRate = output;
    }
}
